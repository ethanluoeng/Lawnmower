Notes:
GPIO 12 and GPIO 13 are open
pinout to see GPIOs to pin numbers

Relay Module:
Allows a low power signal to control a high power load using a relay. (On the primary side, signal sends charge through coiled wires which forms a magnetic field that pushes a metal piece on the secondary side, flipping the output switch.
Light red on back of relay module: Insulates copper traces (under is copper which - Solder).
Silver: Also solder - electrical connections (Its always over the dark red i think)

Tilt Switch:
GPIO port is set to input. 
Tilted upwards: Switch is closed, GPIO port recieves signal
GPIO.add_event_detect(TiltPin, GPIO.BOTH, callback=detect, bouncetime=200): interupts the main method when detect a change of signal from GPIO pin. Advantages, doesn't use a loop to detect readings, simply waits for them. Useful when there are many sensors for example.

Vibration Sensor:
Vibrations temporarily close the circuit, pulling sig to low.

Reed Switch:
Magnetic field closes the circuit, pulling sig to low.

PhotoElectric sensor:
When the light path is blocked, the receiver stops conducting, no path from SIG to GNF, SIG is pulled to high (different this time).
Use code of reed switch.

==============================================================================================================================================================================
PCF8591
https://www.youtube.com/watch?v=IyGwvGzrqp8
To send a byte of data (0 - 255, ie. 1100100 which is 100), you can either send them in parallel (all digits at the same time) which would require 8 wires (7 for the digits, one for ground).
Instead, you can send the data in series (one value after the other) which would only require 2 wires (1 for data, one for ground). Slower but less wires.  

I2C (3 wires: SCL, SDA, Ground):
SDA: Sends the data
SCL: clock generated by the master device. When LOW, the master/slave SDA signal can change. When HIGH, the reciever reads the SDA value at that moment.
Slave addresses are used to determine which slave recieves and reads the data (since they all share the same wires).

SMBus (System Management Bus): 
two-wire, low-speed communication protocol used within computer motherboards for lightweight communication between components like the CPU and power supplies, sensors, and fans. 

PCF8591
4 analog input channels (AIN0â€“AIN3) for reading voltages (e.g. from sensors).
1 analog output (AOUT) for generating analog voltages (e.g. to drive LEDs or control analog devices).
==============================================================================================================================================================================

Rain Drop Module:
Water is conductive; when there's water, circuit connects, IN+ is pulled to low.
2 outputs:
1) Digital Output (DO): LM393 voltage comparator compares voltage coming out from rainboard with a fixed threshold voltage that is set with the potentiometer. Connect this to GPIO pin.
2) Analog Output (AO): This pin is directly connected to the voltage divider circuit created by the resistance of the rain sensing pad. Connect this to PCF8591 input.
**In python, can import scripts as modules if in same folder or if setup the path stuff... (Like classes in Java)

Joystick:
VRx (Voltage Resistive X) & VRy (Voltage Resistive Y): These pins are the outputs from two potentiometers (variable resistors) mounted internally. 
These potentiometers change their resistance as the joystick is moved along the X and Y axes.
They are connected to VCC and GND inside the joystick. 
Ex: Joystick fully left, VRx == 0 (After converting to analog) 
    Joystick fully right, VRx == 255
    Joystick in middle, VRx ~=127
	Joystick at 45 degrees, R = sqrt(VRx^2 + VRy^2) --> solve for VRx and VRy
Button: Uses another VCC and GND for simple circuit.

Potentiometer:
Turn knob adjusts resistance, increasing/decreasing voltage.

Hall effect sensor:
Reed swtich with analog output.

Temperature Module:
Works exactly like Rain Drop Module.

Sound module:
Measures loudness of sound (pretty stupid)

Light module:
Measures intensity of light (more light --> decrease value)

Flame Sensor Module:
detect infrared (IR) light emitted by a flame.

Touch sensor: 
the usual

HC-SR04 Ultrasonic Sensor:
Connect TRIG and ECHO to 2 different GPIO pins. Set Trig pin as OUTPUT and ECHO pin as INPUT.
Send HIGH pulse to the TRIG pin for at least 10 microseconds tells the sensor to fire the 8-cycle burst.
ECHO pin goes to high when the burst is sent and goes back to low when the sensor recieves the reflected echo.
Record the time that ECHO == 1, and use speed of sound to calculate distance.

DS18B20 digital temperature sensor:
Uses the 1 wire (w1) device communication bus: 
Requires only a Data and Ground wire; transferes one bit at a time. Simpler and slower, making it ideal for low-cost, low-power devices.
Reduces cable cost, connector size, and wiring complexity, especially when sensors are deployed in large numbers or over long distances. 
Many devices can share the same bus.
Parasite power: Does not require VCC! During periods when the Master is driving the data line HIGH or LOW for communication, the slave device uses a small internal capacitor to store charge.
DS18B20 automatically converts analog into a digital reading of the temperature which it sends over to the Raspberry pi.

Rotary Encoder:
2 outputs CLK and DT. Reading CLK (how many times it changes 0/1 values) is enough to know magnitude of rotation. 
To determine direction however, CLK is compared with DT each time (they are insynchronus so Ex: CW: DT == SW, CCW: DT != SW).

